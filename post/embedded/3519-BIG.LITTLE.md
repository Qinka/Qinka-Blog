# [ARM big.LITTLE] Linux 大小核独占（方案一）

这篇文章主要是关于 Linux 操作系统中使特定程序独占 big.LITTLE 架构中大核的相关方案的小结。
文中将会介绍一个利用 Linux 内核提供的 `sched_setaffinity` 系统调用设置CPU亲和性（在 Windows 系统中
称之为“CPU相关性”）。本文基于的硬件是华为海思 3519 的 IP 摄像头的开发板，下文中将会有详细介绍。

## big.LITTLE 异构架构

ARM 公司 提出的 big.LITTLE 架构（也就是大小核架构） 是一种异构架构。
由一个或多个性能较为强悍但是功耗较大的核心与一个或多个功耗较小但是计算能力较差的核心组成。

Linux 系统中通过 “开关”模式或者“异构”模式使用这些 核心。本文余下的内容将会于基于异构的方式。

“开关”模式中，每一对大小核都会被当作一个逻辑核，通过切换开关控制在大和或者小核中运行。这样的主要目的是控制功耗。

异构模式则是同时使用多个同尺寸的核心。一个较为常见的一应用场景是：将小核用于运行一般的程序，大核让给主要业务逻辑。本文主要介绍这种使用场景。

## 系统调用 `sched_setaffinity`

本文使用的思路是利用 Linux 的 CPU 亲和性设置。 Linux 调度算法自动将线程调度到亲和性有关处理器上。

Linux 的CPU 亲和性是由一个串二进制掩码控制，例如`0000011`。掩码中，每一位对应一个CPU核心，
从低位开始，分别对应核心 `0`、 核心 `1`……核心 `n`。如果设置掩码为 `00111` 则意味着 前三个核心将
会作为候选，由调度器控制负载，将线程调度到三个CPU 中的一个。

系统调用 `sched_setaffinity` 则可以用来设置这些掩码。

### 使用例程

通过查看 Manual page 中 `sched(7)` 我们可以看见 `sched_setaffinity(2)` 所对应的描述：

```
sched_setaffinity(2)
              (Linux-specific) Set the CPU affinity of a specified thread.
```

然后再查阅 `sched_setaffinity(2)` 的 Manual page 之后。可以获得相关内容。

第一步是包含头文件：

```c
#define _GNU_SOURCE /* feature_test_macros(7)*/
#include <sched.h>
```

其中 `_GNU_SOURCE` 可以参照 `feature_test_macros(7)` 中的说明。

然后第二部是配置设置：

```c
cpu_set_t affinity_mask;

CPU_ZERO(&affinity_mask);
CPU_SET(1,&affinity_mask);
```

其中定义的 `cpu_set_t` 是掩码相关的数据类型。利用宏 `CPU_ZERO` 将标志清零，
然后用宏 `CPU_SET` 将 CPU 1 对应的标识位置1。

最后一步是调用系统调用:

```c
sched_setaffinity(0,sizeof(cpu_set_t),&affinity_mask);
```

第一参数是pid，这里 0 表示当前进程。然后两个参数是设置相关内容。


## 实际结果

这里本文使用到了一个 [测试代码](https://github.com/Qinka/kyo-test-bench/blob/master/src/kyo-tb1.c) 通过简单的计算测量 CPU 的计算速度。

核心计算是四个计算公式：

 * a=2*a+b−c−d+5

 * b=2*b+c−d−a+1

 * c=2*c+d−b−a−3

 * d=2*d+a−b−c+1 
 
 当 a、b、c、d 四个变量的值是递增的时候，这个迭代计算将每个变量的值增加一。
 例如 (1,2,3,4) 在一轮迭代之后将会变成 (2,3,4,5)。
 
 测试的结构如下
 
|       | Cortex A17 | Cortex A7 |
|-------|------------|-----------|
| Score |   36122090 | 103341788 |
| a     |  536870908 | 536870908 |
| b     |  536870909 | 536870909 |
| c     |  536870910 | 536870910 |
| d     |  536870911 | 536870911 |

其中 a、b、c、d 四个值是最后计算的结果。从结果中来看， A7 核心花费的时间是 A17
的 2.86 倍。

从中可以看出，这个方案能使得应用程序再特定 CPU 核心上运行。而利用 该系统调用可以设置其他进程
的相关性，从而达到独占的目的。
此外还能看出 Cortex A7 与 Cortex A17的性能差距。

## 相关 API

掩码位设置宏：

```c
        void CPU_ZERO(cpu_set_t *set);
        void CPU_ZERO_S(size_t setsize, cpu_set_t *set);
        
        void CPU_SET(int cpu, cpu_set_t *set);
        void CPU_SET_S(int cpu, size_t setsize, cpu_set_t *set);
        
        void CPU_CLR(int cpu, cpu_set_t *set);
        void CPU_CLR_S(int cpu, size_t setsize, cpu_set_t *set);
        
        int CPU_ISSET(int cpu, cpu_set_t *set);
        int CPU_ISSET_S(int cpu, size_t setsize, cpu_set_t *set);
        
        void CPU_COUNT(cpu_set_t *set);
        void CPU_COUNT_S(size_t setsize, cpu_set_t *set);
    
        void CPU_AND(cpu_set_t *destset, cpu_set_t *srcset1, cpu_set_t *srcset2);
        void CPU_AND_S(size_t setsize, cpu_set_t *destset, cpu_set_t *srcset1, cpu_set_t *srcset2);
        
        void CPU_OR(cpu_set_t *destset, cpu_set_t *srcset1, cpu_set_t *srcset2);
        void CPU_OR_S(size_t setsize, cpu_set_t *destset, cpu_set_t *srcset1, cpu_set_t *srcset2);
        
        void CPU_XOR(cpu_set_t *destset, cpu_set_t *srcset1, cpu_set_t *srcset2);
        void CPU_XOR_S(size_t setsize, cpu_set_t *destset, cpu_set_t *srcset1, cpu_set_t *srcset2);
        
        int CPU_EQUAL(cpu_set_t *set1, cpu_set_t *set2);
        int CPU_EQUAL_S(size_t setsize, cpu_set_t *set1, cpu_set_t *set2);

```

系统调用：

```c
    int sched_setaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask);
    int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask);
```
