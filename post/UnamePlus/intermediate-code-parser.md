# 中间代码解析器 

实际的 Uname 的中间代码的格式与中间代码的设计略有不同。其中帧与帧之间的分隔符不是使用一行或者是多行的空白而是使用命令`frame`。
同时提高了容错率，其中当有错误的内容传输进来时，会做一些适当的处理来忽略错误内容。

## 中间代码的格式示例

修改过的的中间代码可能长这样：

```
rotate 0
scale 10 10
translate 10 20
frame
1 1 RGB 9 6 7
2 2 
3 3
4 4
5 5 255 0 255
6 6
7 7
8 8
rotate 0.569
frame
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
```
大致类似于这样，其中 `rotate`,`scale`,`translate`这三个是设置坐标平移变换的与旋转的。
`frame` 是控制或者叫分割帧的。
`DOUBLE DOUBLE [COLOR-TYPE] {DOUBLE}` 是每一个点的格式，至少指明点的坐标，然后可以选择性的指明颜色的格式，与颜色的参数。

## 中间代码解析之 解释数字

中间代码解析的一部分内容是解析数字，点与一些命令是需要接受浮点类型的参数的。
所以解析浮点数是先写的内容。浮点数的格式有如下的格式。  
整数部分与小数部分均有。  
`digit{digit}.digit{digit}[(e|E)[+|-]digit{digit}]`  
只有整数部分  
`digit{digit}[.][(e|E)[+|-]digit{digit}]`  
或者只有小数部分  
`.digit{digit}[(e|E)[+|-]dight{digit}]`  

所以解析的时候需要有三个部分。
第一个部分是解析整数部分。

```haskell
intOL :: Parser Double
intOL = do
  f <- read <$> many1 digit
  option '.' $ char '.'
  e <- option id expItem
  return $ e f
```
首先先解析整数部分的那些数字。限制整数部分至少有一位，所以使用 `many1`，然后限制数字类型（十进制）的字符。
读出来的是一系列数字，也就是要转换成最后的数值。有需后面可以跟随一个小数点，则使用 `option` 读取一个小数点。
`option` 使得一个程序尝试读取一个匹配，比如一个字符——“.”，然后如果无法匹配则，就是用默认的一个
