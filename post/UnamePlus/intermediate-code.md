# 中间代码设计

一般很多的的编译器都会分成前后端，前端与后端之间会有一种中间代码。然而这样分的实际原因是 许多中语言的前端会需要共用一个高效的后端。
常见的后端有 GCC 与 LLVM，但是 Uname 这个绘图语言，本身是不需要生成可执行代码的，但是还是需要绘图。而且绘图的后端打算采用多种种实现方式。
目前计划的使用 Haskell+GTK、Matlab 与 LaTeX 三种方式。所以目前的状况是三个绘制后端需要公用一个前端。

对于中间代码的话，应该是尽可能的简单。也就是基本连词法分析器都可以不要。所以尽可能长得想汇编。
用尽可能少的内容，将所要传递的内容在前后端之间传递。

## 中间代码设计考虑因素： UNIX 哲学

为什么要把 UNIX 哲学 放到第一位，没有原因。只是因为 UNIX 哲学之中的原则相对来说是更加适合着个东西的。
核心的 Unix 哲学的内容，所需要的是：让中间代码变成一种简单的文本格式，易于在前后端之间的传输与人为的辨识。
相对于二进制数据来说，更加容易读懂，同时最关键的是方便各种中间件的扩展。

所以中间代码的指令部分与数据部分都是按照文本格式设计。但是因为二进制文件还是有一定优势，所以，
还应该保留直接转换成二进制数据的能力与从二进制数据转换成文本文件的能力。


## 中间代码设计考虑因素： 扩展与兼容

考虑到兼容与扩展，比如说，我们要考虑扩展时间系。也就是说，我们需要添加帧概念，向渲染的后端传递每一帧。这与单纯传递一系列点的方式有一定区别，我们至少要传递区分每一帧的信息。
但是中间代码的可扩展性并不局限在中间代码设计方式。比如说，通过扩展的代码传递的方式来分别每一帧。

而考虑向后兼容的能力(也就是扩展性)的时候，旧的指令解析的程序，处理新的指令集中新的指令的时候
的策略是怎样的，是直接抛弃，还是终止。
同时扩展不能使得解析的难度有增加。解析的时候，无论是什么样的方式，扩展对解析带来的的开销提升，应该尽可能小。

## 中间代码设计考虑因素： 与“底层”更接近

中间代码传递到绘制后端的时候，尽可能的接近绘制后端所能认识 的一种形式。比如说，如果是用 Matlab 作为绘制的后端，则中间代码更适合直接做成一个矩阵。
然而如果是使用 LaTeX， 则需要具体考虑使用哪种 LaTeX 的宏包来绘制这个东西。最接近的程度就是直接输出后端可以识别的那种得失的中间代码。
一般现代编译器，时候后端的时候大都是这样做的。比如使用一般的汇编作为后端，大家都之间产生汇编码就好了。

## 中间代码设计考虑因素： 对多后端的兼容

事实上，虽然需要与底层更接近，但是考虑到对多个后端的支持，但是使用同一份中间代码，则需要一个相对兼容的中间代码与每个后端与中间代码的兼容层。
需要考虑到中间代码到底要表示的信息有哪些。例如 Uname 前后端的中间代码只需要表示一个一个的像素点，算上扩展，也就是还需要关于每个帧的信息。
然后中间代码与后端之间的兼容层则需要进一步将中间代码转换成后端可以看得懂的格式，对于 GTK 来说，需要程序直接解释并绘制。

## 中间代码的设计方案之一 —— 直接传输像素点

就是不考虑任何扩展，直接传递像素点的坐标的话。只需要将坐标点的浮点形式输出到都端的输入即可。格式如下

```
POINT1-X POINT1-Y
POINT2-X POINT2-Y
...
```

每一行记录一个点的信息，每行中通过空格分割，X 与 Y的坐标的位置。至于坐标移动一类的设置，则通过其他方式传递，比如命令行参数。

## 中间代码的设计方案之二 —— 携带坐标平移等额外信息

在方案一中 每一行的如果是字母开头，则意味着是调整坐标的内容。
但是一个比较神奇的问题是，三种后端绘图的坐标设置还不不大相同。这个是有待解决的问题。

## 中间代码的设计方案之三 —— 考虑帧与颜色

先不管额外信息的问题，如果我们要携带帧的信息与颜色的信息，则设计的又有所不同。

首先空行分割每一帧，也就是说，对于着一系列的点来说，没有一个空行，就相当于告诉了绘制后端产生了新的一帧内容。
对于颜色，在每一行之后，添加颜色信息就行了。将 RGB 作为默认的颜色表示方式,而且视同整数表示。其中如果不是使用的 RGB 则需要声明。

例如要绘制点 (1,1) (1,2) (2,1) 分别使用 R，G，B 三种颜色

```
1 1 RGB-INT 255 0 0
1 2 0 255 0
2 1 RGB-DOUBLE 0 0 1
```

这个示例中 表示颜色的方法中，如果是使用默认的 RGB 整数表示的方法来表示，可以省略不写。但是如果是使用其他格式，则需要写清楚。
